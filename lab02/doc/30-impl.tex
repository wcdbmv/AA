\chapter{Технологическая часть}

В данном разделе приведены средства реализации и листинг кода.

\section{Средства реализации}

В качестве языка программирования для реализации данной лабораторной работы был выбран высокопроизводительный язык C++, так как он предоставляет широкие возможности для эффективной реализации алгоритмов.

Для генерации псевдослучайных чисел использована функция \ref{lst:dont_try_to_guess}.

Для замера времени работы алгоритма использованы точнейшие функции библиотеки \code{std::chrono}

\section{Листинг кода}

В листингах \ref{lst:product}--\ref{lst:good_winograd} приведены реализации алгоритмов умножения матриц. Функция замера времени работы алгоритма приведена в листинге \ref{lst:count_time}.

\begin{lstlisting}[caption={Стандартный алгоритм умножения матриц},label={lst:product},style={cpp}]
using row_t = std::vector<double>;
using matrix_t = std::vector<row_t>;

matrix_t create_matrix(size_t rows, size_t cols) {
	return matrix_t(rows, row_t(cols, 0));
}

matrix_t product(const matrix_t& m1, const matrix_t& m2) {
	const size_t l = m1.size();
	const size_t m = m2.size();

	if (!l || !m || m1[0].size() != m) {
		throw std::exception();
	}

	const size_t n = m2[0].size();

	auto result = create_matrix(l, n);
	for (size_t i = 0; i != l; ++i) {
		for (size_t j = 0; j != n; ++j) {
			for (size_t k = 0; k != m; ++k) {
				result[i][j] += m1[i][k] * m2[k][j];
			}
		}
	}

	return result;
}
\end{lstlisting}

\begin{lstlisting}[caption={Алгоритм Копперсмита — Винограда},label={lst:bad_winograd},style={cpp}]
namespace bad {
inline namespace detail {

row_t negative_row_products(const matrix_t& matrix, size_t rows, size_t cols) {
	auto result = row_t(rows, 0);
	for (size_t i = 0; i < rows; i++) {
		for (size_t j = 0; j < cols / 2; j++) {
			result[i] = result[i] + matrix[i][2*j] * matrix[i][2*j + 1];
		}
	}

	return result;
}

row_t negative_col_products(const matrix_t& matrix, size_t rows, size_t cols) {
	auto result = row_t(rows, 0);
	for (size_t i = 0; i < rows; i++) {
		for (size_t j = 0; j < cols / 2; j = j + 2) {
			result[i] = result[i] + matrix[2*j][i] * matrix[2*j + 1][i];
		}
	}

	return result;
}

}  // namespace detail

matrix_t coppersmith_winograd_product(const matrix_t& m1, const matrix_t& m2) {
	const size_t l = m1.size();
	const size_t m = m2.size();

	if (!l || !m || m1[0].size() != m) {
		throw std::exception();
	}

	const size_t n = m2[0].size();

	const auto mh = negative_row_products(m1, l, m);
	const auto mv = negative_col_products(m2, n, m);

	auto result = create_matrix(l, n);
	for (size_t i = 0; i < l; i++) {
		for (size_t j = 0; j < m; j++) {
			result[i][j] = -(mh[i] + mv[j]);
			for (size_t k = 0; k < n / 2; k++) {
				result[i][j] = result[i][j] + (m1[i][2*k + 1] + m2[2*k][j]) * (m1[i][2*k] + m2[2*k + 1][j]);
			}
		}
	}

	if (n % 2) {
		for (size_t i = 0; i < l; i++) {
			for (size_t j = 0; j < m; j++) {
				result[i][j] = result[i][j] + m1[i][n - 1] * m2[n - 1][j];
			}
		}
	}

	return result;
}

}  // namespace bad
\end{lstlisting}

\begin{lstlisting}[caption={Оптимизированный алгоритм Копперсмита — Винограда},label={lst:good_winograd},style={cpp}]
namespace good {
inline namespace detail {

row_t negative_row_products(const matrix_t& matrix, size_t rows, size_t cols) {
	auto result = row_t(rows, 0);
	for (size_t i = 0; i != rows; ++i) {
		for (size_t j = 0; j < cols - 1; j += 2) {
			result[i] -= matrix[i][j] * matrix[i][j + 1];
		}
	}

	return result;
}

row_t negative_col_products(const matrix_t& matrix, size_t rows, size_t cols) {
	auto result = row_t(rows, 0.);
	for (size_t j = 0; j < cols - 1; j += 2) {
		for (size_t i = 0; i != rows; ++i) {
			result[i] -= matrix[j][i] * matrix[j + 1][i];
		}
	}

	return result;
}

}  // namespace detail

matrix_t coppersmith_winograd_product(const matrix_t& m1, const matrix_t& m2) {
	const size_t l = m1.size();
	const size_t m = m2.size();

	if (!l || !m || m1[0].size() != m) {
		throw std::exception();
	}

	const size_t n = m2[0].size();

	const auto mh = negative_row_products(m1, l, m);
	const auto mv = negative_col_products(m2, n, m);

	auto result = create_matrix(l, n);
	for (size_t i = 0; i != l; ++i) {
		for (size_t j = 0; j != m; ++j) {
			result[i][j] = mh[i] + mv[j];
			for (size_t k = 0; k < n - 1; k += 2) {
				result[i][j] += (m1[i][k + 1] + m2[k][j]) * (m1[i][k] + m2[k + 1][j]);
			}
		}
	}

	if (n & 1) {
		for (size_t i = 0; i != l; ++i) {
			for (size_t j = 0; j != m; ++j) {
				result[i][j] += m1[i][n - 1] * m2[n - 1][j];
			}
		}
	}

	return result;
}

}  // namespace good
\end{lstlisting}

\begin{lstlisting}[caption={Продвинутый генератор псевдослучайных чисел},label={lst:dont_try_to_guess},style={cpp}]
int dont_try_to_guess() {
	static thread_local std::mt19937 generator(std::random_device{}());
	static thread_local std::uniform_int_distribution<int> distribution(-1000, 1000);
	return distribution(generator);
}
\end{lstlisting}

\begin{lstlisting}[caption={Функция замера времени работы алгоритмов},label={lst:count_time},style={cpp}]
using product_func_type = matrix_t(const matrix_t&, const matrix_t&);

double count_time(product_func_type product_func, const matrix_t& m1, const matrix_t& m2) {
	constexpr size_t N = 1;

	const auto start = std::chrono::system_clock::now();
	for (int i = 0; i != N; ++i) {
		product_func(m1, m2);
	}
	const auto end = std::chrono::system_clock::now();

	return static_cast<double>(std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count()) / 1.0e9;
}
\end{lstlisting}

\section{Трудоемкость алгоритмов}

\subsection{Стандартный алгоритм умножения матриц}

$f = 2 + l(2 + 2 + n(2 + 2 + m(2 + 9)) = 11lmn + 4ln + 4l + 2$

\subsection{Алгоритм Копперсмита — Винограда}
\begin{enumerate}
	\item $f_{row} = 2 + l(2 + 2 + 0.5n(2 + 10)) = 6ln + 4l + 2$
	\item $f_{col} = 2 + n(2 + 2 + 0.5m(2 + 10)) = 6mn + 4n + 2$
	\item $f_{matrix} = 2 + l(2 + 2 + m(2 + 2 + 7 + 0.5n(2 + 22)) = 12lmn + 11lm + 4l + 2$
	\item $f_{end} = \begin{cases}
	2, & \text{mtr is even,}\\
	2 + 2 + l(2 + 2 + m(2 + 13)) = 15lm + 4l + 4, & \text{otherwise.}
	\end{cases}$
\end{enumerate}

Итого, для худшего случая (нечетный размер матрицы) $f = f_{row} + f_{col} + f_{matrix} + f_{end} = 12lmn + 6ln + 6mn + 26lm + 12l + 4n + 10 \approx 12lmn$

Для лучшего случая (четный размер матрицы: $f = f_{row} + f_{col} + f_{matrix} + f_{end} = 12lmn + 6ln + 6mn + 11lm + 8l + 4n + 8 \approx 12lmn$

\subsection{Оптимизированный алгоритм Копперсмита — Винограда}
\begin{enumerate}
	\item $f_{row} = 2 + l(2 + 2 + 0.5n(2 + 8)) = 5ln - l + 2$
	\item $f_{col} = 2 + n(2 + 2 + 0.5m(2 + 8)) = 5mn - n + 2$
	\item $f_{matrix} = 2 + l(2 + 2 + m(2 + 2 + 5 + 0.5n(2 + 15)) = 8.5lmn + 9lm + 4l + 2$
	\item $f_{end} = \begin{cases}
	2, & \text{mtr is even,}\\
	2 + 2 + l(2 + 2 + m(2 + 10)) = 12lm + 4l + 4, & \text{otherwise.}
	\end{cases}$
\end{enumerate}

Итого, для худшего случая (нечетный размер матрицы) $f = f_{row} + f_{col} + f_{matrix} + f_{end} = 8.5lmn + 5ln + 5mn + 21lm + 7l - n + 10 \approx 8lmn$

Для лучшего случая (четный размер матрицы): $f = f_{row} + f_{col} + f_{matrix} + f_{end} = 8.5lmn + 5ln + 5mn + 11lm + 3l - n + 8 \approx 8lmn$

\section{Тестирование фунций}

В таблице~\ref{tabular:test_rec} приведены тесты для функций, реализующих стандартный алгоритм умнодения матриц (СА), алгоритм Винограда (АВ) и оптимизированный алгоритм Винограда (АВ(О))

\begin{table}
	\begin{center}
		\begin{tabular}{c@{\hspace{7mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}}
			\hline
			Матрица 1 & Матрица 2 &Ожидаемый результат &СА & АВ & АВ(О) \\ \hline
			\vspace{4mm}
			$\begin{pmatrix}
			1 & 2 & 3\\
			1 & 2 & 3\\
			1 & 2 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
			1 & 2 & 3\\
			1 & 2 & 3\\
			1 & 2 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
			6 & 12 & 18\\
			6 & 12 & 18\\
			6 & 12 & 18
			\end{pmatrix}$ & $\surd$ & $\surd$ & $\surd$\\
			\vspace{2mm}
			\vspace{2mm}
			$\begin{pmatrix}
			1 & 2\\
			1 & 2
			\end{pmatrix}$ &
			$\begin{pmatrix}
			1 & 2\\
			1 & 2
			\end{pmatrix}$ &
			$\begin{pmatrix}
			3 & 6\\
			3 & 6
			\end{pmatrix}$ & $\surd$ & $\surd$ & $\surd$\\
			\vspace{2mm}
			\vspace{2mm}
			$\begin{pmatrix}
			2
			\end{pmatrix}$ &
			$\begin{pmatrix}
			2
			\end{pmatrix}$ &
			$\begin{pmatrix}
			4
			\end{pmatrix}$ & $\surd$ & $\surd$ & $\surd$\\
			\vspace{2mm}
			\vspace{2mm}
			$\begin{pmatrix}
			1 & -2 & 3\\
			1 & 2 & 3\\
			1 & 2 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
			-1 & 2 & 3\\
			1 & 2 & 3\\
			1 & 2 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
			0 & 4 & 6\\
			4 & 12 & 18\\
			4 & 12 & 18
			\end{pmatrix}$ & $\surd$ & $\surd$ & $\surd$\\
		\end{tabular}
	\end{center}
	\caption{\label{tabular:test_rec} Тестирование функций}
\end{table}

\section*{Вывод}

Правильный выбор инструментов разработки позволил эффективно реализовать алгоритмы, настроить модульное тестирование и выполнить исследовательский раздел лабораторной работы.
